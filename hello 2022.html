<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    hello 2022!
</body>
</html>

우선 하이퍼레져 패브릭의 피어의 개념과 역할을 파악한 후... 


블록체인 네트워크는 피어노드(간단히 피어)들의 집합으로 구성되어 있다. 
피어들은 네트워크의 기본적인 구성요소이다. 왜냐하면 원장과 스마트계약을 호스팅하기 때문이다. 
스마트 계약에 의해 생성된 모든 트랜잭션을 원장이 기록한다는 점을 상기
스마트 계약과 원장은 캡슐화하는데 사용된다. 공유프로세스와 공유정보를 네트워크에서  각각
스마트 계약과 원장은 각각 공유프로세스와 공유정보를 네트워크에서 캡슐화하는데 사용된다.
피어의 이러한 측면 패브릭 네트워크를 이해하는데 좋은 출발점이 된다. 


블록체인 네트워크는 피어 노드로 구성되며, 각 노드는 장부 사본과 스마트 계약 사본을 보유할 수 있다. 
이 예에서, 네트워크 N은 피어 P1, P2, P3으로 구성되며, 각각은 분산 원장의 인스턴스를 유지한다.

피어는 생성, 시작, 중지, 재구성, 심지어 삭제될 수 있다. 
피어는 관리자 및 응용 프로그램이 제공하는 서비스와 상호 작용할 수 있는 API 집합을 expose한다. 


체인코드≒스마트 컨트랙트

피어는 원장의 인스턴스와 체인코드의 인스턴스를 호스팅한다. 이렇게 하면 의도적인 이중화를 제공하여
single point of failure 를 방지할 수 있다. 

single point of failure
기능이 제대로 작동하지 않을 경우 전체 시스템에 장애를 발생하는 시스템의 비중복적인 부분. 

그림1 P1 S1 L1
피어는 

피어가 원장가 체인코드의 master이기 때문에, 
아플리케이션과 관리자들은 이런 자원들에 접근하기 위해서는 반드시 피어와의 상호작용이 필요하다. 
이게 피어가 패브릭 네트워크의 가장 중요한 기초로 간주되는 이유이다. 
피어가 처음 생성되면, 원장도. 체인코드도 갖고 있지 않다. 


피어는 하나 이상의 원장을 호스팅할 수 있다. 
이건 유연한 시스템 디자인을 가능하게 하기 때문에 유용하다. 
가장 간단한 구성은 피어가 하나의 원장을 관리하는 것이지만.  
요구된다면 피어는 두개이상의 원장을 호스팅하는 것이 적합하다. 


# Multiple Chaincodes

피어는 하나 이상의 원장을 호스팅하며 
각 원장은 0개 이상의 체인 코드를 적용한다. 
이 예에서는 P1 이 L1 및 L2를 호스트하고, L1은 체인코드 S1을 사용하여 접근한다. 
반면, 레더 L2는 체인 코드 S1과 S2를 사용하여 접근한다.

체인 코드는 단일 채널에서 인스턴스화된다.
각 채널(및 원장)은 채널과 상호 작용하는 여러 체인 코드를 가질 수 있다. 



Applications and Peers
원장-쿼리는 애플리케이션과 피어 사이의 간단한 dialogue를 포함.
반면 원장-업데이트(쓰기)는 추가 단계를 포함

클라이언트 아플리케이션은 원장과 체인코드에 접근하기 위해 피어의 패브릭 게이트웨이 서비스와 연결된다. 
Fabric v2.4부터 Gateway SDK를 사용하면 프로그래머들이 쉽게 사용할 수 있따. API를 사용하면 응용프로그램이 
게이트웨이를 통해 트렌젝션 제안서를 제출하고, 승인을 용청하고. 이벤트를 수신하고, 
승인된 트랜잭션을 주문 서비스에 전할 수 있따. 


게이트웨이의 피어 연결을 통해서 응용 프로그램은 체인 코드를 실행하여 원장을 읽거나 갱신할 수 있다. 
원장-쿼리 트랜잭션의 결과는 단순한 처리로 반환되는 반면에 
원장-업데이트(쓰기)는 아플리케이션, 피어. 주문자 간의 좀 더 복잡한 작업흐름을 포함한다. 

피어는 orderers와 함께 보장한다. 원장이 채널의 모든 피어에서 일관되고 최신상태로 유지되는 것을 보장한다. 


# Applications and Peers


## 1.  Transaction Proposal and Endorsement

원장 업데이트(쓰기)의 첫번째 단계는 트랜잭션 제안서 제출과 실행, 그리고 승인으로 구성되어 있다. 

a) Transaction proposal 
클라이언트 애플리케이션이 제출한다. 서명된 트랜잭션 제안서를 P1의 게이트웨이 서비스를 통해서. 
클라이언트 애플리케이션은 게이트웨이 서비스에게 승인 조직의 선택을 위임하거나 
보증에 필요한 조직을 명시적으로 식별해야 한다. 

b) Transaction execution
게이트웨이 서비스는 P1이나 같은 조직의 다른 피어를 선택하고, 트랜잭션을 실행한다. 
선택된 피어는 제안에 의해 지정된 체인코드를 실행한다. 읽기-쓰기등을 포함하는 제안 응답을 생성한다. 
선택된 피어는 제안 응답에 서명하고 게이트웨이로 반환한다.  

c)Transaction endorsement
게이트웨이는 체인코드 보증정책에서 요구하는 각 조직에 대해 트랜잭션 실행(b)을 반복한다. 
게이트웨이 서비스는 서명된 제안 응답을 수집한다. 그리고 트랜잭션 봉투를 만들고 서명을 위해 클라이언트에게 반환한다. 

## 2. Transaction Submission and Ordering

a) Transaction submission 
클라이언트는 서명된 트랜잭션 봉투를 게이트웨이 서비스에 보낸다. 
게이트웨이는 그 봉투를 ordering node에게 전달하고, 성공메세지를 클라이언트에게 반환한다. 

b) Transaction ordering 
ordering 노드 는 서명을 검증한다. 그리고 ordering service가 트랜잭션을 주문하고, 다른 주문 트랜잭션과 함께 
블록으로 패키징한다. 그리고나서 주문 서비스는 원장에 대한 유효성 검사와 commitment를 위해 채널의 모든 피어에 블록을 배포한다. 


### 3.  Transaction Validation and Commitment

a) Transaction validation 
각각의 피어는 확인한다. 그.. 트랜잭션에 동봉된 클라이언트의 서명이 일치하는지.  워래 트랜잭션 제안서에 있는 서명이랑 . 
또한 각 피어는 확인한다 모든 읽기-쓰기 집합과 상태 응답이 동일한지(모든 피어의 보증이 일치하는지) 확인하고.각 보증이 보증정책을 만족하는지 확인한다. 각 피어는 원장에 각 트랜잭션을 유효 or 무효로 표시한다. 원장의 commitment 를 위해. 

b) Transaction commitment
각 피어는 정렬된 트랜잭션 블록을 채널 원장에 커밋한다. 
커밋은 채널 원장에 대한 불변의 ledger update다. 
채널의 world state(모든 유효한 트랜잭션의 합)는 오직 유효한 트랜잭션 결과만으로 갱신된다. 

c) Commit event 
원장에 커밋된 각 피어는 클라이언트에게 원장 업데이트 증명과 함께 커밋 상태 이벤트를 보낸다. 

# Peers and Channels
채널 컴포넌트는 피어노드들과, orderer 노드와 아플리케이션을 포함한다. 
채널에 가입함으로써, 그들은 동의한다.  일괄적으로 관리하고 공유하기위해 협력하기로,

채널을 친구그룹과 비교할 수 있다. 한 사람의 여러 그룹의 친구를 가질 수 있고, 각 그룹은
서로 다른 활동에 참여할 수 있다. 그룹은 완전히 분리되어 있거나, 그들 사이에 크로스오버 멤버십이 있을 수 있다. 그럼에도 불구하고, 각 친구그룹은 회원 자격을 확립하고 유지하는 특정 규칙을 가진 entity다. 

채널 멤버십은 다른 그룹에서와 같은 방식으로 작동한다. 
어떤 피어는 여러 채널에 속할 수 있고, 각 채널에 특정한 원장과 체인코드를 유지할 수 있다.
또는 피어는 오직 하나의 채널에만 속하고 따라야 하는 하나의 규칙의 집합만 가지고 있다. 

채널은 특정 아플리케이션 집합과 피어가 서로 Fabric 블록체인 네트워크에서 의사소통하는 것을 허용한다.  예를 들어 A라는 아플리케이션은 채널 C에 있는 게이트웨이 서비스를 통해서 Peer1 과 Peer2와 소통한다. 채널은 특정 아플리케이션과 피어들의 커뮤니케이션을 위한 통로다. 

채널은 피어와 같은 방식으로 존재하지 않는다. 채널을 물리적 피어의 컬렉션에 의해 형성된 논리적 구조라 생각하는 것이 더 정확하다. 
피어는 채널에 대한 액세스 및 관리를 위한 컨트롤 포인트를 제공한다. 


# Peers and Organizations
Fabric 블록체인 네트워크는 하나의 조직보다 조직들의 컬렉션에 의해서 관리된다. 
피어는 조직이 소유하고 있는 네트워크 연결지점이기 때문에 분산 네트워크 구축 방법의 중심이라고 할 수 있다. 

총 8개의 피어로 구성된 4개의 조직이 네트워크를 구성하고 있다고 생각해보자.

      A1        A2        A3    A4 
    [P1,P2] [P3,P4,P5] [P6,P7] [P8]
     -       -     -        -    - 
     |       |     |        |    | 
     -----------Channel C---------          
============== Network N ===============

채널 C 는 네트워크 N 에서 다섯개의 피어와 연결되어 있다.

위 조직이 소유하고 있는 다른 피어들은 채널에 가입되어 있지 않다. 하지만 하나 이상의 다른 채널에 가입한다. 
// A1 조직의 P1은 채널 C에 join 한 상태, P2는 다른 채널에 가입되어 있음??

조직에서 개발한 아플리케이션은 Fabric 게이트웨이 서비스를 통해 피어와 연결하고, 채널의 다른 조직의 피어에도 연결된다. 

네트워크는 리소스를 제공하는 여러 조직에 의해 형성되고 관리된다. 이 항목에서 설명하는 리소스는 피어지만, 조직들은 체인코드나 ordering service node 같은 다른 리소스도 제공한다. 

조직이 네트워크에 개별 자원을 기여하지 않는다면, 네트워크는 존재하지 않는다. 
네트워크는 협력하는 조직이 자원을 제공함에 따라 성장하고, 복원력과 보안이 증가한다.

보면 알겠지만 중앙집권화된 리소스는 없다. 만약에 조직들이 그들의 피어와 다른 자원을 제공하지 않으면 네트워크 N은 존재하지 않는다. 
네트워크는 어떤 개별 조직에도 의존하지 않는다. 네트워크 구성원이 네트워크가 자체적으로 저의한 요구사항을 충족하는 한 계속 존재한다. 이게 분산된 네트워크의 heart다. 네트워크 모든 회원의 조직은 동등하게 공유하고 기여한다. 

각 조직에서 사용하는 아플리케이션은 같을 수도 있고.. 같지 않을 수도 있다. 
왜냐 각각의 조직 원장에 있는 데이터를 어떻게 사용할지 정할 수 있기 때문이다. 
모든 피어가 동일한 원장 사본을 호스팅하더라도. 앞플리케이션과 표현논리는 조직에 따라 다를 수가 있다. 


 # Peers and Identity  
 피어들이 그들의 관리자에 의해 어떻게 조직에 할당되는지...

 피어는 특정인증기관의 디지털 인증서를 통해 할당된 identity가 있다. 
 네트워크의 모든 피어에 소유하고 있는 조직의 관리자가 디지털 인증서를 할당한다.

 피어가 채널에 연결되면, 해당 디지털 인증서는 채널 MSP를 통해 소유조직을 식별한다. 
 위 예에서 P1 및 P2는 CA1에서 발급한 ID를 갖는다. 채널 C는 채널 구성의 정책을 통해 CA1의 ID가 ORG1.MSP를 사용하여 ORG1과 연결되도록 한다. 마찬가지로 P3와 P4도 ORG2로 식별된다.

 피어가 Fabric 네트워크 채널에 연결할 때마다 채널 구성의 정책은 피어의 ID를 사용하여 피어의 권한을 결정한다. 조직에 대한 ID 매핑은 MSP라는 컴포넌트에 의해 제공된다. 이 컴포넌트는 피어가 특정 조직에서 특정 역할에 할당되어 리소스에 대한 인증된 접근 권한을 얻는 방법을 결정한다. 또한 피어는 단일 조직에서만 소유할 수 있으므로 단일 MSP와 연결된다. MSP는 패브릭 네트워크의 특정 조직 역할과 개별 ID를 연결하는 것으로 생각하면 된다. 

 피어, 패브릭네트워크와 상호작용하는 모든 것은 디지털 인증서와 MSP에서 조직 ID를 얻는다.
 피어, 아플리케이션, 최종 사용자, 관리자 및 주문자는 네트워크와 상호작용하려면 각각 ID랑 관련된 MSP를 가지고 있어야 한다. 

 아이디를 사용해서 블록체인 네트워크와 상호작용하는 모든 엔티티를 주체라고 한다. 
 ID는 피어가 실제로 위치한 


































